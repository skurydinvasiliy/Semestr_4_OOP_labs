import java.util.*;

/**
 * Этот класс хранит базовое состояние, необходимое для алгоритма A * для
 * вычисления пути по карте. Это состояние включает в себя коллекцию «открытых
 * путевых точек» и другую коллекцию «закрытых путевых точек». Кроме того, этот
 * класс предоставляет основные операции, необходимые алгоритму поиска пути A*
 * для его обработки.
 **/
public class AStarState
{
    /**
     * Это ссылка на карту, на которой работает навигация (навигирует?) алгоритм А*
     **/
    private Map2D map;

    /** Инициализация карты всех отытых точек и их полжений **/
    private Map<Location, Waypoint> open_waypoints
            = new HashMap<Location, Waypoint> ();

    /** Инициализация карты всех закрытых точек и их полжений **/
    private Map<Location, Waypoint> closed_waypoints
            = new HashMap<Location, Waypoint> ();

    /** Инициализация новоо статического объекта для использования алгоритма
     * нахождения пути А*  **/
    public AStarState(Map2D map)
    {
        if (map == null)
            throw new NullPointerException("map cannot be null");

        this.map = map;
    }

    /** Возврат карты, на которой работает навиагция алгоритма нахождения пути А* **/
    public Map2D getMap()
    {
        return map;
    }

    /** Этот метод сканирует через все открытые путевые точки, и возвращает
     * путевую точку с минимальной общей стоимостью (пути?). Есои там нет
     * открытых путевых точек, этот метод созвращает код  <code>null</code> **/
    public Waypoint getMinOpenWaypoint()
    {
        /** Если нет открытых путевых точек - возвращает <code>null</code> **/
        if (numOpenWaypoints() == 0)
            return null;

        /** Инициализация набора ключей всех открытых путевых точек, интератор (?)
         * для итерации через набор и переменная для удержания лучшей путевой точки
         * и стоимости для этой путевой точки
         **/
        Set open_waypoint_keys = open_waypoints.keySet();
        Iterator i = open_waypoint_keys.iterator();
        Waypoint best = null;
        float best_cost = Float.MAX_VALUE;

        /**
         * Сканирует через все открытые путевые точки
         **/
        while (i.hasNext())
        {
            /** Хранит текущее местоположение **/
            Location location = (Location)i.next();

            /** Хранит текущую путевую точку **/
            Waypoint waypoint = open_waypoints.get(location);

            /** Хранит общую стоимость для текущих путевых точек **/
            float waypoint_total_cost = waypoint.getTotalCost();

            /** Если общая стоимость для текущей путевой точки лучше (ниже),
             *  чем сохраненная стоимость для сохраненной наилучшей путевой точки,
             *  замените сохраненную путевую точку на текущую путевую точку и
             *  сохраненную общую стоимость с текущей общей стоимостью.  **/
            if (waypoint_total_cost < best_cost)
            {
                best = open_waypoints.get(location);
                best_cost = waypoint_total_cost;
            }

        }

        /** Возврат путевой точки с минимальной общей стоимостью **/
        return best;
    }

    /** Этот метод добавляет путевую точку (или потенциально обновляет путевую
     * точку, уже находящуюся в) в коллекцию «открытых путевых точек». Если уже
     * нет открытой путевой точки на новой местоположении, то новая путевая
     * точка просто добавляется в коллекцию. Однако, если в местоположении
     * новой путевой точки уже есть путевая точка, новая путевая точка заменяет
     * старую <em>, только если </ em> значение «предыдущей стоимости» новой
     * путевой точки меньше значения «предыдущей стоимости» текущей путевой точки.
     **/
    public boolean addOpenWaypoint(Waypoint newWP)
    {

        /** Находит местоположение новой пуевой точки **/
        Location location = newWP.getLocation();

        /** Проверяет, есть ли уже открытая путевая точка в местоположении новой путевой точки. **/
        if (open_waypoints.containsKey(location))
        {

            /** Если уже есть открытая путевая точка в местоположении новой
             * путевой точки, проверяется, меньше ли значение "предыдущей
             * стоимости" новой путевой точки, чем значение "предыдущей стоимости"
             * текущей путевой точки.
             **/
            Waypoint current_waypoint = open_waypoints.get(location);
            if (newWP.getPreviousCost() < current_waypoint.getPreviousCost())
            {

                /** Если значение «предыдущей стоимости» новой путевой точки
                 * меньше значения «предыдущей стоимости» текущей путевой точки,
                 * новая путевая точка заменяет старую путевую точку и возвращает true.
                 **/
                open_waypoints.put(location, newWP);
                return true;
            }

            /** Если значение «предыдущей стоимости» новой путевой точки не меньше,
             * чем значение «предыдущей стоимости» текущей путевой точки, вернуть false.
             **/
            return false;
        }

        /** Если в местоположении новой путевой точки еще нет открытой путевой
         *  точки, добавьте новую путевую точку в коллекцию открытых путевых точек
         *  и верните true. **/
        open_waypoints.put(location, newWP);
        return true;
    }

    /** Возвращение текущено номера открытых путевых точек **/
    public int numOpenWaypoints()
    {
        return open_waypoints.size();
    }

    /**Этот метод перемещает путевую точку на указанное место из открытого
     * списка в закрытый (список доступных/недоступных точек видимо) **/

    public void closeWaypoint(Location loc)
    {
        Waypoint waypoint = open_waypoints.remove(loc);
        closed_waypoints.put(loc, waypoint);
    }

    /** Возвращает true, если коллекция закрытых путевых точек имеет путевую
     *  точку для указанного места **/
    public boolean isLocationClosed(Location loc)
    {
        return closed_waypoints.containsKey(loc);
    }
}